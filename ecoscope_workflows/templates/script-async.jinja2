{% import 'call-task-macros.jinja' as call_task_macros %}

{%- if testing %}
"""WARNING: This file is generated in a testing context and should not be used in production.
Lines specific to the testing context are marked with a test tube emoji (ðŸ§ª) to indicate
that they would not be included (or would be different) in the production version of this file.
"""
{% endif -%}

import argparse
import os
import yaml
{%- if testing %}
import warnings  # ðŸ§ª
from ecoscope_workflows.testing import create_task_magicmock  # ðŸ§ª
{% endif %}

from ecoscope_workflows.executors import LithopsExecutor
from ecoscope_workflows.graph import DependsOn, DependsOnSequence, Graph, Node

{% for t in spec.workflow -%}
{{ t.known_task.importable_reference.statement }}
{% if loop.last %}
{% endif -%}
{% endfor -%}
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    g = parser.add_argument_group("{{ spec.id }}")
    g.add_argument(
        "--config-file",
        dest="config_file",
        required=True,
        type=argparse.FileType(mode="r"),
    )
    args = parser.parse_args()
    params = yaml.safe_load(args.config_file)
    {%- if testing %}
    warnings.warn("This test script should not be used in production!")  # ðŸ§ª
    {% endif %}

    le = LithopsExecutor()

    dependencies = ...

    nodes = {
        {% for t in spec.workflow %}
        {% set validate = true %}
        {% set params = 'params["' ~ t.id ~ '"]' %}
        {% set set_executor = 'le' %}
        "{{ t.id }}": Node(
            async_callable=(
                {{ call_task_macros.create_callable(t, validate, params, set_executor) }}
            ),
            {% if t.method != "call" %}
            {% if t.method == "map" %}
                {% set argnames = t.map.argnames %}
                {% set argvalues = t.map.argvalues["aslist"] %}
            {% elif t.method == "mapvalues" %}
                {% set argnames = t.mapvalues.argnames %}
                {% set argvalues = t.mapvalues.argvalues["aslist"] %}
            {% endif %}
            params={
                "argnames": {{ argnames }},
                {% if argvalues|length > 1 %}
                "argvalues": DependsOnSequence(
                    [
                        {% for v in argvalues %}
                        DependsOn("{{ v }}"),
                        {% endfor %}
                    ]
                ),
                {% else %}
                "argvalues": DependsOn("{{ argvalues[0] }}"),
                {% endif %}
            },
            {% endif %}
        ),
        {% endfor -%}
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    print(results)
