# Parameters for 'Set Groupers' using task `set_groupers`.
groupers:
  groupers:   # (list[ecoscope_workflows.tasks.groupby._groupby.Grouper], FieldInfo(annotation=NoneType, required=True, description='            Index(es) and/or column(s) to group by, along with\n            optional display names and help text.\n            '))

# Parameters for 'Get Patrol Events from EarthRanger' using task `get_patrol_events`.
patrol_events:
  client:   # (<class 'ecoscope_workflows.connections.EarthRangerClientProtocol'>, BeforeValidator(func=<bound method DataConnection.client_from_named_connection of <class 'ecoscope_workflows.connections.EarthRangerConnection'>>), WithJsonSchema(json_schema={'type': 'string', 'description': 'A named EarthRanger connection.'}, mode=None))
  since:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='Start date'))
  until:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='End date'))
  patrol_type:   # (list[str], FieldInfo(annotation=NoneType, required=True, description='list of UUID of patrol types'))
  status:   # (list[str], FieldInfo(annotation=NoneType, required=True, description="list of 'scheduled'/'active'/'overdue'/'done'/'cancelled'"))

# Parameters for 'Apply Relocation Coordinate Filter' using task `apply_reloc_coord_filter`.
filter_patrol_events:
  min_x:   # (<class 'float'>, FieldInfo(annotation=NoneType, required=False, default=-180.0))
  max_x:   # (<class 'float'>, FieldInfo(annotation=NoneType, required=False, default=180.0))
  min_y:   # (<class 'float'>, FieldInfo(annotation=NoneType, required=False, default=-90.0))
  max_y:   # (<class 'float'>, FieldInfo(annotation=NoneType, required=False, default=90.0))
  filter_point_coords:   # (list[ecoscope_workflows.tasks.transformation._filtering.Coordinate], FieldInfo(annotation=NoneType, required=False, default=[Coordinate(x=0.0, y=0.0)]))

# Parameters for 'Add temporal index to Patrol Events' using task `add_temporal_index`.
pe_add_temporal_index:
  index_name:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='A name for the new index which will be added.'))
  time_col:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='Name of existing column containing time data.'))
  directive:   # (typing.Literal['%a', '%A', '%b', '%B', '%c', '%d', '%f', '%H', '%I', '%j', '%m', '%M', '%p', '%S', '%U', '%w', '%W', '%x', '%X', '%y', '%Y', '%z', '%%'], FieldInfo(annotation=NoneType, required=True, description='A directive for formatting the time data.'))
  cast_to_datetime:   # (<class 'bool'>, FieldInfo(annotation=NoneType, required=True, description='Whether to attempt casting `time_col` to datetime.'))
  format:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='            If `cast_to_datetime=True`, the format to pass to `pd.to_datetime`\n            when attempting to cast `time_col` to datetime. Defaults to "mixed".\n            '))

# Parameters for 'Patrol Events Colormap' using task `apply_color_map`.
pe_colormap:
  input_column_name:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The name of the column with categorical values.'))
  colormap:   # (str | list[str], FieldInfo(annotation=NoneType, required=True, description='Either a named mpl.colormap or a list of string hex values.'))
  output_column_name:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='The dataframe column that will contain the color values.'))

# Parameters for 'Create map layer from Patrol Events' using task `create_map_layer`.
pe_map_layer:
  layer_style:   # (ecoscope_workflows.tasks.results._ecomap.PolylineLayerStyle | ecoscope_workflows.tasks.results._ecomap.PolygonLayerStyle | ecoscope_workflows.tasks.results._ecomap.PointLayerStyle, FieldInfo(annotation=NoneType, required=True, description='Style arguments for the layer.'))
  legend:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.LegendDefinition, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='If present, includes this layer in the map legend'))

# Parameters for 'Draw Ecomap from Time Density' using task `draw_ecomap`.
pe_ecomap:
  tile_layer:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='A named tile layer, ie OpenStreetMap.'))
  static:   # (<class 'bool'>, FieldInfo(annotation=NoneType, required=True, description='Set to true to disable map pan/zoom.'))
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The map title.'))
  north_arrow_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.NorthArrowStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional arguments for configuring the North Arrow.'))
  legend_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.LegendStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional arguments for configuring the legend.'))

# Parameters for 'Persist Ecomap as Text' using task `persist_text`.
pe_ecomap_html_url:
  filename:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='            Optional filename to persist text to within the `root_path`.\n            If not provided, a filename will be generated based on a hash of the text content.\n            '))

# Parameters for 'Create Time Density Map Widget' using task `create_map_widget_single_view`.
pe_map_widget:
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The title of the widget'))
  view:   # (tuple[tuple[str, typing.Literal['='], str], ...] | None, FieldInfo(annotation=NoneType, required=True, description='If grouped, the view of the widget', exclude=True))

# Parameters for 'Draw Time Series Bar Chart for Patrols Events' using task `draw_time_series_bar_chart`.
pe_bar_chart:
  x_axis:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The dataframe column to plot in the x/time axis.'))
  y_axis:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The dataframe column to plot in the y axis.'))
  category:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The dataframe column to stack in the y axis.'))
  agg_function:   # (typing.Literal['count', 'mean', 'sum', 'min', 'max'], FieldInfo(annotation=NoneType, required=True, description='The aggregate function to apply to the group.'))
  time_interval:   # (typing.Literal['year', 'month', 'week', 'day', 'hour'], FieldInfo(annotation=NoneType, required=True, description='Sets the time interval of the x axis.'))
  color_column:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='The name of the dataframe column to color bars with.'))
  grouped_styles:   # (list[ecoscope_workflows.tasks.results._ecoplot.GroupedPlotStyle], FieldInfo(annotation=NoneType, required=True, description='Style arguments passed to plotly.graph_objects.Bar and applied to individual groups.'))
  plot_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecoplot.PlotStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional style kwargs passed to go.Bar().'))
  layout_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecoplot.BarLayoutStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional kwargs passed to plotly.go.Figure(layout).'))

# Parameters for 'Persist Patrols Bar Chart as Text' using task `persist_text`.
pe_bar_chart_html_url:
  filename:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='            Optional filename to persist text to within the `root_path`.\n            If not provided, a filename will be generated based on a hash of the text content.\n            '))

# Parameters for 'Create Plot Widget for Patrol Events' using task `create_plot_widget_single_view`.
pe_bar_chart_widget:
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The title of the widget'))
  view:   # (tuple[tuple[str, typing.Literal['='], str], ...] | None, FieldInfo(annotation=NoneType, required=True, description='If grouped, the view of the widget', exclude=True))

# Parameters for 'Create Patrol Events Meshgrid' using task `create_meshgrid`.
pe_meshgrid:
  cell_width:   # (<class 'int'>, FieldInfo(annotation=NoneType, required=True, description='The width of a grid cell in meters.'))
  cell_height:   # (<class 'int'>, FieldInfo(annotation=NoneType, required=True, description='The height of a grid cell in meters.'))
  intersecting_only:   # (<class 'bool'>, FieldInfo(annotation=NoneType, required=True, description='Whether to return only grid cells intersecting with the aoi.'))

# Parameters for 'Patrol Events Feature Density' using task `calculate_feature_density`.
pe_feature_density:
  geometry_type:   # (typing.Literal['point', 'line'], FieldInfo(annotation=NoneType, required=True, description='The geometry type of the provided geodataframe'))

# Parameters for 'Feature Density Colormap' using task `apply_color_map`.
fd_colormap:
  input_column_name:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The name of the column with categorical values.'))
  colormap:   # (str | list[str], FieldInfo(annotation=NoneType, required=True, description='Either a named mpl.colormap or a list of string hex values.'))
  output_column_name:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='The dataframe column that will contain the color values.'))

# Parameters for 'Create map layer from Feature Density' using task `create_map_layer`.
fd_map_layer:
  layer_style:   # (ecoscope_workflows.tasks.results._ecomap.PolylineLayerStyle | ecoscope_workflows.tasks.results._ecomap.PolygonLayerStyle | ecoscope_workflows.tasks.results._ecomap.PointLayerStyle, FieldInfo(annotation=NoneType, required=True, description='Style arguments for the layer.'))
  legend:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.LegendDefinition, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='If present, includes this layer in the map legend'))

# Parameters for 'Draw Ecomap from Feature Density' using task `draw_ecomap`.
fd_ecomap:
  tile_layer:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='A named tile layer, ie OpenStreetMap.'))
  static:   # (<class 'bool'>, FieldInfo(annotation=NoneType, required=True, description='Set to true to disable map pan/zoom.'))
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The map title.'))
  north_arrow_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.NorthArrowStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional arguments for configuring the North Arrow.'))
  legend_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.LegendStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional arguments for configuring the legend.'))

# Parameters for 'Persist Feature Density Ecomap as Text' using task `persist_text`.
fd_ecomap_html_url:
  filename:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='            Optional filename to persist text to within the `root_path`.\n            If not provided, a filename will be generated based on a hash of the text content.\n            '))

# Parameters for 'Create Feature Density Map Widget' using task `create_map_widget_single_view`.
fd_map_widget:
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The title of the widget'))
  view:   # (tuple[tuple[str, typing.Literal['='], str], ...] | None, FieldInfo(annotation=NoneType, required=True, description='If grouped, the view of the widget', exclude=True))

# Parameters for 'Split Patrol Events by Group' using task `split_groups`.
split_patrol_event_groups:

# Parameters for 'Create map layer from grouped Patrol Events' using task `create_map_layer`.
grouped_pe_map_layer:
  layer_style:   # (ecoscope_workflows.tasks.results._ecomap.PolylineLayerStyle | ecoscope_workflows.tasks.results._ecomap.PolygonLayerStyle | ecoscope_workflows.tasks.results._ecomap.PointLayerStyle, FieldInfo(annotation=NoneType, required=True, description='Style arguments for the layer.'))
  legend:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.LegendDefinition, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='If present, includes this layer in the map legend'))

# Parameters for 'Draw Ecomap from grouped Patrol Events' using task `draw_ecomap`.
grouped_pe_ecomap:
  tile_layer:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='A named tile layer, ie OpenStreetMap.'))
  static:   # (<class 'bool'>, FieldInfo(annotation=NoneType, required=True, description='Set to true to disable map pan/zoom.'))
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The map title.'))
  north_arrow_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.NorthArrowStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional arguments for configuring the North Arrow.'))
  legend_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.LegendStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional arguments for configuring the legend.'))

# Parameters for 'Persist grouped Patrol Events Ecomap as Text' using task `persist_text`.
grouped_pe_ecomap_html_url:
  filename:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='            Optional filename to persist text to within the `root_path`.\n            If not provided, a filename will be generated based on a hash of the text content.\n            '))

# Parameters for 'Create grouped Patrol Events Map Widget' using task `create_map_widget_single_view`.
grouped_pe_map_widget:
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The title of the widget'))

# Parameters for 'Merge Patrol Events Map Widget Views' using task `merge_widget_views`.
grouped_pe_map_widget_merge:

# Parameters for 'Draw Pie Chart for Patrols Events' using task `draw_pie_chart`.
grouped_pe_pie_chart:
  value_column:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The name of the dataframe column to pull slice values from.'))
  label_column:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='The name of the dataframe column to label slices with, required if the data in value_column is numeric.'))
  color_column:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='The name of the dataframe column to color slices with.'))
  plot_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecoplot.PlotStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional style kwargs passed to go.Pie().'))
  layout_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecoplot.LayoutStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional kwargs passed to plotly.go.Figure(layout).'))

# Parameters for 'Persist Patrols Pie Chart as Text' using task `persist_text`.
grouped_pe_pie_chart_html_urls:
  filename:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='            Optional filename to persist text to within the `root_path`.\n            If not provided, a filename will be generated based on a hash of the text content.\n            '))

# Parameters for 'Create Plot Widget for Patrol Events' using task `create_plot_widget_single_view`.
grouped_pe_pie_chart_widgets:
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The title of the widget'))

# Parameters for 'Merge Pie Chart Widget Views' using task `merge_widget_views`.
grouped_pe_pie_widget_merge:

# Parameters for 'Grouped Patrol Events Feature Density' using task `calculate_feature_density`.
grouped_pe_feature_density:
  geometry_type:   # (typing.Literal['point', 'line'], FieldInfo(annotation=NoneType, required=True, description='The geometry type of the provided geodataframe'))

# Parameters for 'Grouped Feature Density Colormap' using task `apply_color_map`.
grouped_fd_colormap:
  input_column_name:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The name of the column with categorical values.'))
  colormap:   # (str | list[str], FieldInfo(annotation=NoneType, required=True, description='Either a named mpl.colormap or a list of string hex values.'))
  output_column_name:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='The dataframe column that will contain the color values.'))

# Parameters for 'Create map layer from Feature Density' using task `create_map_layer`.
grouped_fd_map_layer:
  layer_style:   # (ecoscope_workflows.tasks.results._ecomap.PolylineLayerStyle | ecoscope_workflows.tasks.results._ecomap.PolygonLayerStyle | ecoscope_workflows.tasks.results._ecomap.PointLayerStyle, FieldInfo(annotation=NoneType, required=True, description='Style arguments for the layer.'))
  legend:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.LegendDefinition, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='If present, includes this layer in the map legend'))

# Parameters for 'Draw Ecomap from Feature Density' using task `draw_ecomap`.
grouped_fd_ecomap:
  tile_layer:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='A named tile layer, ie OpenStreetMap.'))
  static:   # (<class 'bool'>, FieldInfo(annotation=NoneType, required=True, description='Set to true to disable map pan/zoom.'))
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The map title.'))
  north_arrow_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.NorthArrowStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional arguments for configuring the North Arrow.'))
  legend_style:   # (typing.Union[ecoscope_workflows.tasks.results._ecomap.LegendStyle, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='Additional arguments for configuring the legend.'))

# Parameters for 'Persist Feature Density Ecomap as Text' using task `persist_text`.
grouped_fd_ecomap_html_url:
  filename:   # (typing.Union[str, typing.Annotated[NoneType, SkipJsonSchema()]], FieldInfo(annotation=NoneType, required=True, description='            Optional filename to persist text to within the `root_path`.\n            If not provided, a filename will be generated based on a hash of the text content.\n            '))

# Parameters for 'Create Feature Density Map Widget' using task `create_map_widget_single_view`.
grouped_fd_map_widget:
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The title of the widget'))

# Parameters for 'Merge Feature Density Widget Views' using task `merge_widget_views`.
grouped_fd_map_widget_merge:

# Parameters for 'Create Dashboard with Patrol Map Widgets' using task `gather_dashboard`.
patrol_dashboard:
  title:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The title of the dashboard'))
  description:   # (<class 'str'>, FieldInfo(annotation=NoneType, required=True, description='The description of the dashboard'))
